<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>GEN242 – Tutorials</title>
    <link>/tutorials/</link>
    <description>Recent content in Tutorials on GEN242</description>
    <generator>Hugo -- gohugo.io</generator>
    
	  <atom:link href="/tutorials/index.xml" rel="self" type="application/rss+xml" />
    
    
      
        
      
    
    
    <item>
      <title>Tutorials: Programming in R</title>
      <link>/tutorials/rprogramming/rprogramming/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/tutorials/rprogramming/rprogramming/</guid>
      <description>
        
        
        &lt;hr&gt;
&lt;p&gt;title: “Programming in R”
author: “Author: Thomas Girke”
date: “Last update: 13 February, 2021”
output:
html_document:
toc: true
toc_float:
collapsed: true
smooth_scroll: true
toc_depth: 3
fig_caption: yes
code_folding: show
number_sections: true&lt;/p&gt;
&lt;p&gt;fontsize: 14pt
bibliography: bibtex.bib
—&lt;/p&gt;
&lt;!--
- Compile from command-line
Rscript -e &#34;rmarkdown::render(&#39;Programming_in_R.Rmd&#39;, c(&#39;html_document&#39;), clean=F); knitr::knit(&#39;Programming_in_R.Rmd&#39;, tangle=TRUE)&#34;; Rscript ../md2jekyll.R Programming_in_R.knit.md 9; Rscript -e &#34;rmarkdown::render(&#39;Programming_in_R.Rmd&#39;, c(&#39;pdf_document&#39;))&#34;
--&gt;
&lt;script type=&#34;text/javascript&#34;&gt;
document.addEventListener(&#34;DOMContentLoaded&#34;, function() {
  document.querySelector(&#34;h1&#34;).className = &#34;title&#34;;
});
&lt;/script&gt;
&lt;script type=&#34;text/javascript&#34;&gt;
document.addEventListener(&#34;DOMContentLoaded&#34;, function() {
  var links = document.links;  
  for (var i = 0, linksLength = links.length; i &lt; linksLength; i++)
    if (links[i].hostname != window.location.hostname)
      links[i].target = &#39;_blank&#39;;
});
&lt;/script&gt;
&lt;h1 id=&#34;overview&#34;&gt;Overview&lt;/h1&gt;
&lt;p&gt;One of the main attractions of using the R
(&lt;a href=&#34;http://cran.at.r-project.org&#34;&gt;http://cran.at.r-project.org&lt;/a&gt;) environment is
the ease with which users can write their own programs and custom functions.
The R programming syntax is extremely easy to learn, even for users with no
previous programming experience. Once the basic R programming control
structures are understood, users can use the R language as a powerful
environment to perform complex custom analyses of almost any type of data (&lt;span class=&#34;citeproc-not-found&#34; data-reference-id=&#34;Gentleman2008-xo&#34;&gt;&lt;strong&gt;???&lt;/strong&gt;&lt;/span&gt;).&lt;/p&gt;
&lt;h2 id=&#34;why-programming-in-r&#34;&gt;Why Programming in R?&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Powerful statistical environment and programming language&lt;/li&gt;
&lt;li&gt;Facilitates reproducible research&lt;/li&gt;
&lt;li&gt;Efficient data structures make programming very easy&lt;/li&gt;
&lt;li&gt;Ease of implementing custom functions&lt;/li&gt;
&lt;li&gt;Powerful graphics&lt;/li&gt;
&lt;li&gt;Access to fast growing number of analysis packages&lt;/li&gt;
&lt;li&gt;Most widely used language in bioinformatics&lt;/li&gt;
&lt;li&gt;Is standard for data mining and biostatistical analysis&lt;/li&gt;
&lt;li&gt;Technical advantages: free, open-source, available for all OSs&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;r-basics&#34;&gt;R Basics&lt;/h2&gt;
&lt;p&gt;The previous &lt;a href=&#34;http://girke.bioinformatics.ucr.edu/GEN242/mydoc/mydoc_Rbasics_01.html&#34;&gt;Rbasics&lt;/a&gt; tutorial provides a general introduction to the usage of the R environment and its basic command syntax.
More details can be found in the R &amp;amp; BioConductor manual &lt;a href=&#34;http://manuals.bioinformatics.ucr.edu/home/R_BioCondManual&#34;&gt;here&lt;/a&gt;.&lt;/p&gt;
&lt;h2 id=&#34;code-editors-for-r&#34;&gt;Code Editors for R&lt;/h2&gt;
&lt;p&gt;Several excellent code editors are available that provide functionalities like R syntax highlighting, auto code indenting and utilities to send code/functions to the R console.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.rstudio.com/products/rstudio/features/&#34;&gt;RStudio&lt;/a&gt;: GUI-based IDE for R&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://manuals.bioinformatics.ucr.edu/home/programming-in-r/vim-r&#34;&gt;Vim-R-Tmux&lt;/a&gt;: R working environment based on vim and tmux&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.xemacs.org/Download/index.html&#34;&gt;Emacs&lt;/a&gt; (&lt;a href=&#34;http://ess.r-project.org/&#34;&gt;ESS add-on package&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://wiki.gnome.org/Apps/Gedit&#34;&gt;gedit&lt;/a&gt; and &lt;a href=&#34;https://wiki.gnome.org/Apps/Gedit&#34;&gt;Rgedit&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://rkward.kde.org/&#34;&gt;RKWard&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.walware.de/goto/statet&#34;&gt;Eclipse&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://jekyll.math.byuh.edu/other/howto/tinnr/install.shtml&#34;&gt;Tinn-R&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://sourceforge.net/projects/npptor/&#34;&gt;Notepad++ (NppToR)&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;center&gt;
&lt;p&gt;Programming in R using RStudio&lt;/p&gt;
&lt;/center&gt;
&lt;center&gt;
&lt;img title=&#34;R_Interfaces&#34; src=&#34;images/rstudio.png&#34;/&gt;
&lt;/center&gt;
&lt;center&gt;
&lt;p&gt;Programming in R using Vim or Emacs&lt;/p&gt;
&lt;/center&gt;
&lt;center&gt;
&lt;img title=&#34;vim-r&#34; src=&#34;images/vimR.png&#34;/&gt;
&lt;/center&gt;
&lt;h2 id=&#34;finding-help&#34;&gt;Finding Help&lt;/h2&gt;
&lt;p&gt;Reference list on R programming (selection)&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://adv-r.had.co.nz/&#34;&gt;Advanced R&lt;/a&gt;, by Hadley Wickham&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://master.bioconductor.org/help/publications/books/r-programming-for-bioinformatics/&#34;&gt;R Programming for Bioinformatics&lt;/a&gt;, by Robert Gentleman&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.stats.ox.ac.uk/pub/MASS3/Sprog/&#34;&gt;S Programming&lt;/a&gt;, by W. N. Venables and B. D. Ripley&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.amazon.com/Programming-Data-Language-Lecture-Economics/dp/0387985034&#34;&gt;Programming with Data&lt;/a&gt;, by John M. Chambers&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www1.maths.lth.se/help/R/&#34;&gt;R Help&lt;/a&gt; &amp;amp; &lt;a href=&#34;http://www1.maths.lth.se/help/R/RCC/&#34;&gt;R Coding Conventions&lt;/a&gt;, Henrik Bengtsson, Lund University&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://zoonek2.free.fr/UNIX/48_R/02.html&#34;&gt;Programming in R&lt;/a&gt; (Vincent Zoonekynd)&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www2.warwick.ac.uk/fac/sci/moac/people/students/peter_cock/r&#34;&gt;Peter’s R Programming Pages&lt;/a&gt;, University of Warwick&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://pj.freefaculty.org/R/statsRus.html&#34;&gt;Rtips&lt;/a&gt;, Paul Johnsson, University of Kansas&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://heather.cs.ucdavis.edu/~matloff/r.html&#34;&gt;R for Programmers&lt;/a&gt;, Norm Matloff, UC Davis&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.statistik.uni-dortmund.de/useR-2008/tutorials/useR2008introhighperfR.pdf&#34;&gt;High-Performance R&lt;/a&gt;, Dirk Eddelbuettel tutorial presented at useR-2008&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.stat.harvard.edu/ccr2005/index.html&#34;&gt;C/C++ level programming for R&lt;/a&gt;, Gopi Goswami&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;control-structures&#34;&gt;Control Structures&lt;/h1&gt;
&lt;h2 id=&#34;important-operators&#34;&gt;Important Operators&lt;/h2&gt;
&lt;h3 id=&#34;comparison-operators&#34;&gt;Comparison operators&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;==&lt;/code&gt; (equal)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;!=&lt;/code&gt; (not equal)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&amp;gt;&lt;/code&gt; (greater than)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&amp;gt;=&lt;/code&gt; (greater than or equal)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&amp;lt;&lt;/code&gt; (less than)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&amp;lt;=&lt;/code&gt; (less than or equal)&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;logical-operators&#34;&gt;Logical operators&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;&amp;amp;&lt;/code&gt; (and)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;|&lt;/code&gt; (or)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;!&lt;/code&gt; (not)&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;conditional-executions-if-statements&#34;&gt;Conditional Executions: &lt;code&gt;if&lt;/code&gt; Statements&lt;/h2&gt;
&lt;p&gt;An &lt;code&gt;if&lt;/code&gt; statement operates on length-one logical vectors.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Syntax&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;if(TRUE) { 
    statements_1 
} else { 
    statements_2 
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;Example&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;if(1==0) { 
    print(1) 
} else { 
    print(2) 
}
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] 2
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;conditional-executions-ifelse-statements&#34;&gt;Conditional Executions: &lt;code&gt;ifelse&lt;/code&gt; Statements&lt;/h2&gt;
&lt;p&gt;The &lt;code&gt;ifelse&lt;/code&gt; statement operates on vectors.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Syntax&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;ifelse(test, true_value, false_value)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;Example&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;x &amp;lt;- 1:10 
ifelse(x&amp;lt;5, x, 0)
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##  [1] 1 2 3 4 0 0 0 0 0 0
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;loops&#34;&gt;Loops&lt;/h1&gt;
&lt;h2 id=&#34;for-loop&#34;&gt;&lt;code&gt;for&lt;/code&gt; loop&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;for&lt;/code&gt; loops iterate over elements of a looping vector.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Syntax&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;for(variable in sequence) { 
    statements 
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;Example&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;mydf &amp;lt;- iris
myve &amp;lt;- NULL
for(i in seq(along=mydf[,1])) {
    myve &amp;lt;- c(myve, mean(as.numeric(mydf[i,1:3])))
}
myve[1:8]
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] 3.333333 3.100000 3.066667 3.066667 3.333333 3.666667 3.133333 3.300000
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;Note:&lt;/strong&gt; Inject into objecs is much faster than append approach with &lt;code&gt;c&lt;/code&gt;, &lt;code&gt;cbind&lt;/code&gt;, etc.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Example&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;myve &amp;lt;- numeric(length(mydf[,1]))
for(i in seq(along=myve)) {
    myve[i] &amp;lt;- mean(as.numeric(mydf[i,1:3]))
}
myve[1:8]
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] 3.333333 3.100000 3.066667 3.066667 3.333333 3.666667 3.133333 3.300000
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;conditional-stop-of-loops&#34;&gt;Conditional Stop of Loops&lt;/h3&gt;
&lt;p&gt;The &lt;code&gt;stop&lt;/code&gt; function can be used to break out of a loop (or a function) when a condition becomes &lt;code&gt;TRUE&lt;/code&gt;. In addition, an error message will be printed.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Example&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;x &amp;lt;- 1:10
z &amp;lt;- NULL
for(i in seq(along=x)) { 
    if(x[i] &amp;lt; 5) { 
        z &amp;lt;- c(z, x[i]-1)  
    } else { 
        stop(&amp;quot;values need to be &amp;lt; 5&amp;quot;) 
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;while-loop&#34;&gt;&lt;code&gt;while&lt;/code&gt; loop&lt;/h2&gt;
&lt;p&gt;Iterates as long as a condition is true.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Syntax&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;while(condition) {
    statements
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;Example&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;z &amp;lt;- 0
while(z&amp;lt;5) { 
    z &amp;lt;- z + 2
    print(z)  
}
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] 2
## [1] 4
## [1] 6
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;the-apply-function-family&#34;&gt;The &lt;code&gt;apply&lt;/code&gt; Function Family&lt;/h2&gt;
&lt;h3 id=&#34;apply&#34;&gt;&lt;code&gt;apply&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;Syntax&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;apply(X, MARGIN, FUN, ARGs)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;Arguments&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;X&lt;/code&gt;: &lt;code&gt;array&lt;/code&gt;, &lt;code&gt;matrix&lt;/code&gt; or &lt;code&gt;data.frame&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;MARGIN&lt;/code&gt;: &lt;code&gt;1&lt;/code&gt; for rows, &lt;code&gt;2&lt;/code&gt; for columns&lt;/li&gt;
&lt;li&gt;&lt;code&gt;FUN&lt;/code&gt;: one or more functions&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ARGs&lt;/code&gt;: possible arguments for functions&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;Example&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;apply(iris[1:8,1:3], 1, mean)
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##        1        2        3        4        5        6        7        8 
## 3.333333 3.100000 3.066667 3.066667 3.333333 3.666667 3.133333 3.300000
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;tapply&#34;&gt;&lt;code&gt;tapply&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;Applies a function to vector components that are defined by a factor.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Syntax&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;tapply(vector, factor, FUN)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;Example&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;iris[1:2,]
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##   Sepal.Length Sepal.Width Petal.Length Petal.Width Species
## 1          5.1         3.5          1.4         0.2  setosa
## 2          4.9         3.0          1.4         0.2  setosa
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;tapply(iris$Sepal.Length, iris$Species, mean)
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##     setosa versicolor  virginica 
##      5.006      5.936      6.588
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;sapply-and-lapply&#34;&gt;&lt;code&gt;sapply&lt;/code&gt; and &lt;code&gt;lapply&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;Both apply a function to vector or list objects. The &lt;code&gt;lapply&lt;/code&gt; function always returns a list object, while &lt;code&gt;sapply&lt;/code&gt; returns &lt;code&gt;vector&lt;/code&gt; or &lt;code&gt;matrix&lt;/code&gt; objects when it is possible.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Examples&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;l &amp;lt;- list(a = 1:10, beta = exp(-3:3), logic = c(TRUE,FALSE,FALSE,TRUE))
lapply(l, mean)
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## $a
## [1] 5.5
## 
## $beta
## [1] 4.535125
## 
## $logic
## [1] 0.5
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;sapply(l, mean)
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##        a     beta    logic 
## 5.500000 4.535125 0.500000
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Often used in combination with a function definition:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;lapply(names(l), function(x) mean(l[[x]]))
sapply(names(l), function(x) mean(l[[x]]))
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;functions&#34;&gt;Functions&lt;/h1&gt;
&lt;h2 id=&#34;function-overview&#34;&gt;Function Overview&lt;/h2&gt;
&lt;p&gt;A very useful feature of the R environment is the possibility to expand existing functions and to easily write custom functions. In fact, most of the R software can be viewed as a series of R functions.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Syntax&lt;/strong&gt; to define function&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;myfct &amp;lt;- function(arg1, arg2, ...) { 
    function_body 
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;Syntax&lt;/strong&gt; to call functions&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;myfct(arg1=..., arg2=...)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The value returned by a function is the value of the function body, which is usually an unassigned final expression, &lt;em&gt;e.g.&lt;/em&gt;: &lt;code&gt;return()&lt;/code&gt;&lt;/p&gt;
&lt;h2 id=&#34;function-syntax-rules&#34;&gt;Function Syntax Rules&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;General&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Functions are defined by
&lt;ol&gt;
&lt;li&gt;The assignment with the keyword &lt;code&gt;function&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;The declaration of arguments/variables (&lt;code&gt;arg1, arg2, ...&lt;/code&gt;)&lt;/li&gt;
&lt;li&gt;The definition of operations (&lt;code&gt;function_body&lt;/code&gt;) that perform computations on the provided arguments. A function name needs to be assigned to call the function.&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;Naming&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Function names can be almost anything. However, the usage of names of existing functions should be avoided.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;Arguments&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;It is often useful to provide default values for arguments (&lt;em&gt;e.g.&lt;/em&gt;: &lt;code&gt;arg1=1:10&lt;/code&gt;). This way they don’t need to be provided in a function call. The argument list can also be left empty (&lt;code&gt;myfct &amp;lt;- function() { fct_body }&lt;/code&gt;) if a function is expected to return always the same value(s). The argument &lt;code&gt;...&lt;/code&gt; can be used to allow one function to pass on argument settings to another.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;Body&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;The actual expressions (commands/operations) are defined in the function body which should be enclosed by braces. The individual commands are separated by semicolons or new lines (preferred).&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;Usage&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Functions are called by their name followed by parentheses containing possible argument names. Empty parenthesis after the function name will result in an error message when a function requires certain arguments to be provided by the user. The function name alone will print the definition of a function.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;Scope&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Variables created inside a function exist only for the life time of a function. Thus, they are not accessible outside of the function. To force variables in functions to exist globally, one can use the double assignment operator: &lt;code&gt;&amp;lt;&amp;lt;-&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;examples&#34;&gt;Examples&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;Define sample function&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;myfct &amp;lt;- function(x1, x2=5) { 
    z1 &amp;lt;- x1 / x1
    z2 &amp;lt;- x2 * x2
        myvec &amp;lt;- c(z1, z2) 
        return(myvec)
} 
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;Function usage&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Apply function to values &lt;code&gt;2&lt;/code&gt; and &lt;code&gt;5&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;myfct(x1=2, x2=5) 
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1]  1 25
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Run without argument names&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;myfct(2, 5) 
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1]  1 25
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Makes use of default value &lt;code&gt;5&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;myfct(x1=2) 
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1]  1 25
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Print function definition (often unintended)&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;myfct 
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## function(x1, x2=5) { 
##  z1 &amp;lt;- x1 / x1
##  z2 &amp;lt;- x2 * x2
##         myvec &amp;lt;- c(z1, z2) 
##         return(myvec)
## }
## &amp;lt;bytecode: 0x5865ccde4df0&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;useful-utilities&#34;&gt;Useful Utilities&lt;/h1&gt;
&lt;h2 id=&#34;debugging-utilities&#34;&gt;Debugging Utilities&lt;/h2&gt;
&lt;p&gt;Several debugging utilities are available for R. They include:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;traceback&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;browser&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;options(error=recover)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;options(error=NULL)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;debug&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;The &lt;a href=&#34;http://www.stats.uwo.ca/faculty/murdoch/software/debuggingR/&#34;&gt;Debugging in R page&lt;/a&gt; provides an overview of the available resources.&lt;/p&gt;
&lt;h2 id=&#34;regular-expressions&#34;&gt;Regular Expressions&lt;/h2&gt;
&lt;p&gt;R’s regular expression utilities work similar as in other languages. To learn how to use them in R, one can consult the main help page on this topic with &lt;code&gt;?regexp&lt;/code&gt;.&lt;/p&gt;
&lt;h3 id=&#34;string-matching-with-grep&#34;&gt;String matching with &lt;code&gt;grep&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;The grep function can be used for finding patterns in strings, here letter &lt;code&gt;A&lt;/code&gt; in vector &lt;code&gt;month.name&lt;/code&gt;.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;month.name[grep(&amp;quot;A&amp;quot;, month.name)] 
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] &amp;quot;April&amp;quot;  &amp;quot;August&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;string-substitution-with-gsub&#34;&gt;String substitution with &lt;code&gt;gsub&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;Example for using regular expressions to substitute a pattern by another one using a back reference. Remember: single escapes &lt;code&gt;\&lt;/code&gt; need to be double escaped &lt;code&gt;\\&lt;/code&gt; in R.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;gsub(&#39;(i.*a)&#39;, &#39;xxx_\\1&#39;, &amp;quot;virginica&amp;quot;, perl = TRUE) 
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] &amp;quot;vxxx_irginica&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;interpreting-a-character-string-as-expression&#34;&gt;Interpreting a Character String as Expression&lt;/h2&gt;
&lt;p&gt;Some useful examples&lt;/p&gt;
&lt;p&gt;Generates vector of object names in session&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;mylist &amp;lt;- ls()
mylist[1] 
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] &amp;quot;i&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Executes 1st entry as expression&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;get(mylist[1])
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] 150
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Alternative approach&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;eval(parse(text=mylist[1])) 
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] 150
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;replacement-split-and-paste-functions-for-strings&#34;&gt;Replacement, Split and Paste Functions for Strings&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;Selected examples&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Substitution with back reference which inserts in this example &lt;code&gt;_&lt;/code&gt; character&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;x &amp;lt;- gsub(&amp;quot;(a)&amp;quot;,&amp;quot;\\1_&amp;quot;, month.name[1], perl=T) 
x
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] &amp;quot;Ja_nua_ry&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Split string on inserted character from above&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;strsplit(x,&amp;quot;_&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [[1]]
## [1] &amp;quot;Ja&amp;quot;  &amp;quot;nua&amp;quot; &amp;quot;ry&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Reverse a character string by splitting first all characters into vector fields&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;paste(rev(unlist(strsplit(x, NULL))), collapse=&amp;quot;&amp;quot;) 
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] &amp;quot;yr_aun_aJ&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;time-date-and-sleep&#34;&gt;Time, Date and Sleep&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;Selected examples&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Return CPU (and other) times that an expression used (here ls)&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;system.time(ls()) 
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##    user  system elapsed 
##       0       0       0
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Return the current system date and time&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;date() 
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] &amp;quot;Sat Feb 13 18:30:39 2021&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Pause execution of R expressions for a given number of seconds (e.g. in loop)&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;Sys.sleep(1) 
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;example&#34;&gt;Example&lt;/h3&gt;
&lt;h4 id=&#34;import-of-specific-file-lines-with-regular-expression&#34;&gt;Import of Specific File Lines with Regular Expression&lt;/h4&gt;
&lt;p&gt;The following example demonstrates the retrieval of specific lines from an external file with a regular expression. First, an external file is created with the &lt;code&gt;cat&lt;/code&gt; function, all lines of this file are imported into a vector with &lt;code&gt;readLines&lt;/code&gt;, the specific elements (lines) are then retieved with the &lt;code&gt;grep&lt;/code&gt; function, and the resulting lines are split into vector fields with &lt;code&gt;strsplit&lt;/code&gt;.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;cat(month.name, file=&amp;quot;zzz.txt&amp;quot;, sep=&amp;quot;\n&amp;quot;)
x &amp;lt;- readLines(&amp;quot;zzz.txt&amp;quot;)
x[1:6] 
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] &amp;quot;January&amp;quot;  &amp;quot;February&amp;quot; &amp;quot;March&amp;quot;    &amp;quot;April&amp;quot;    &amp;quot;May&amp;quot;      &amp;quot;June&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;x &amp;lt;- x[c(grep(&amp;quot;^J&amp;quot;, as.character(x), perl = TRUE))]
t(as.data.frame(strsplit(x, &amp;quot;u&amp;quot;)))
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##                 [,1]  [,2] 
## c..Jan....ary.. &amp;quot;Jan&amp;quot; &amp;quot;ary&amp;quot;
## c..J....ne..    &amp;quot;J&amp;quot;   &amp;quot;ne&amp;quot; 
## c..J....ly..    &amp;quot;J&amp;quot;   &amp;quot;ly&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;calling-external-software&#34;&gt;Calling External Software&lt;/h2&gt;
&lt;p&gt;External command-line software can be called with &lt;code&gt;system&lt;/code&gt;. The following example calls &lt;code&gt;blastall&lt;/code&gt; from R&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;system(&amp;quot;blastall -p blastp -i seq.fasta -d uniprot -o seq.blastp&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## Warning in system(&amp;quot;blastall -p blastp -i seq.fasta -d uniprot -o seq.blastp&amp;quot;): error in running
## command
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;running-r-scripts&#34;&gt;Running R Scripts&lt;/h1&gt;
&lt;h2 id=&#34;possibilities-for-executing-r-scripts&#34;&gt;Possibilities for Executing R Scripts&lt;/h2&gt;
&lt;h3 id=&#34;r-console&#34;&gt;R console&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;source(&amp;quot;my_script.R&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;command-line&#34;&gt;Command-line&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;Rscript my_script.R # or just ./myscript.R after making it executable
R CMD BATCH my_script.R # Alternative way 1 
R --slave &amp;lt; my_script.R # Alternative way 2
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;passing-arguments-from-command-line-to-r&#34;&gt;Passing arguments from command-line to R&lt;/h3&gt;
&lt;p&gt;Create an R script named &lt;code&gt;test.R&lt;/code&gt; with the following content:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;myarg &amp;lt;- commandArgs()
print(iris[1:myarg[6], ])
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Then run it from the command-line like this:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;Rscript test.R 10
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;In the given example the number &lt;code&gt;10&lt;/code&gt; is passed on from the command-line as an argument to the R script which is used to return to &lt;code&gt;STDOUT&lt;/code&gt; the first 10 rows of the &lt;code&gt;iris&lt;/code&gt; sample data. If several arguments are provided, they will be interpreted as one string and need to be split in R with the strsplit function. A more detailed example can be found &lt;a href=&#34;http://manuals.bioinformatics.ucr.edu/home/ht-seq#TOC-Quality-Reports-of-FASTQ-Files-&#34;&gt;here&lt;/a&gt;.&lt;/p&gt;
&lt;h1 id=&#34;building-r-packages&#34;&gt;Building R Packages&lt;/h1&gt;
&lt;h2 id=&#34;short-overview-of-package-building-process&#34;&gt;Short Overview of Package Building Process&lt;/h2&gt;
&lt;p&gt;R packages can be built with the &lt;code&gt;package.skeleton&lt;/code&gt; function. The given example will create a directory named &lt;code&gt;mypackage&lt;/code&gt; containing the skeleton of the package for all functions, methods and classes defined in the R script(s) passed on to the &lt;code&gt;code_files&lt;/code&gt; argument. The basic structure of the package directory is described &lt;a href=&#34;http://manuals.bioinformatics.ucr.edu/home/programming-in-r#Progr_pack&#34;&gt;here&lt;/a&gt;. The package directory will also contain a file named &lt;code&gt;Read-and-delete-me&lt;/code&gt; with instructions for completing the package:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;package.skeleton(name=&amp;quot;mypackage&amp;quot;, code_files=c(&amp;quot;script1.R&amp;quot;, &amp;quot;script2.R&amp;quot;))
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Once a package skeleton is available one can build the package from the command-line (Linux/OS X). This will create a tarball of the package with its version number encoded in the file name. Subequently, the package tarball needs to be checked for errors with:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;R CMD build mypackage
R CMD check mypackage_1.0.tar.gz
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Install package from source&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;install.packages(&amp;quot;mypackage_1.0.tar.gz&amp;quot;, repos=NULL) 
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;For more details see &lt;a href=&#34;http://manuals.bioinformatics.ucr.edu/home/programming-in-r#TOC-Building-R-Packages&#34;&gt;here&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&#34;programming-exercises&#34;&gt;Programming Exercises&lt;/h1&gt;
&lt;h2 id=&#34;exercise-1&#34;&gt;Exercise 1&lt;/h2&gt;
&lt;h3 id=&#34;for-loop-1&#34;&gt;&lt;code&gt;for&lt;/code&gt; loop&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;Task 1.1&lt;/strong&gt;: Compute the mean of each row in &lt;code&gt;myMA&lt;/code&gt; by applying the mean function in a &lt;code&gt;for&lt;/code&gt; loop.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;myMA &amp;lt;- matrix(rnorm(500), 100, 5, dimnames=list(1:100, paste(&amp;quot;C&amp;quot;, 1:5, sep=&amp;quot;&amp;quot;)))
myve_for &amp;lt;- NULL
for(i in seq(along=myMA[,1])) {
    myve_for &amp;lt;- c(myve_for, mean(as.numeric(myMA[i, ])))
}
myResult &amp;lt;- cbind(myMA, mean_for=myve_for)
myResult[1:4, ]
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##           C1           C2         C3         C4         C5    mean_for
## 1  1.7988703  0.785864023  1.2763288  0.2950553  0.9858471  1.02839310
## 2 -0.9683694  2.724133446 -0.8274809 -0.3208423 -0.4600894  0.02947028
## 3 -1.1476365 -0.002864923  1.2573494  0.9574395  1.0390970  0.42067691
## 4 -0.3476123  0.639676778 -1.4706145 -1.3904486 -0.1612300 -0.54604574
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;while-loop-1&#34;&gt;&lt;code&gt;while&lt;/code&gt; loop&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;Task 1.2&lt;/strong&gt;: Compute the mean of each row in &lt;code&gt;myMA&lt;/code&gt; by applying the mean function in a &lt;code&gt;while&lt;/code&gt; loop.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;z &amp;lt;- 1
myve_while &amp;lt;- NULL
while(z &amp;lt;= length(myMA[,1])) {
    myve_while &amp;lt;- c(myve_while, mean(as.numeric(myMA[z, ])))
    z &amp;lt;- z + 1
}
myResult &amp;lt;- cbind(myMA, mean_for=myve_for, mean_while=myve_while)
myResult[1:4, -c(1,2)]
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##           C3         C4         C5    mean_for  mean_while
## 1  1.2763288  0.2950553  0.9858471  1.02839310  1.02839310
## 2 -0.8274809 -0.3208423 -0.4600894  0.02947028  0.02947028
## 3  1.2573494  0.9574395  1.0390970  0.42067691  0.42067691
## 4 -1.4706145 -1.3904486 -0.1612300 -0.54604574 -0.54604574
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;Task 1.3&lt;/strong&gt;: Confirm that the results from both mean calculations are identical&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;all(myResult[,6] == myResult[,7])
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] TRUE
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;apply-loop&#34;&gt;&lt;code&gt;apply&lt;/code&gt; loop&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;Task 1.4&lt;/strong&gt;: Compute the mean of each row in myMA by applying the mean function in an &lt;code&gt;apply&lt;/code&gt; loop&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;myve_apply &amp;lt;- apply(myMA, 1, mean)
myResult &amp;lt;- cbind(myMA, mean_for=myve_for, mean_while=myve_while, mean_apply=myve_apply)
myResult[1:4, -c(1,2)]
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##           C3         C4         C5    mean_for  mean_while  mean_apply
## 1  1.2763288  0.2950553  0.9858471  1.02839310  1.02839310  1.02839310
## 2 -0.8274809 -0.3208423 -0.4600894  0.02947028  0.02947028  0.02947028
## 3  1.2573494  0.9574395  1.0390970  0.42067691  0.42067691  0.42067691
## 4 -1.4706145 -1.3904486 -0.1612300 -0.54604574 -0.54604574 -0.54604574
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;avoiding-loops&#34;&gt;Avoiding loops&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;Task 1.5&lt;/strong&gt;: When operating on large data sets it is much faster to use the rowMeans function&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;mymean &amp;lt;- rowMeans(myMA)
myResult &amp;lt;- cbind(myMA, mean_for=myve_for, mean_while=myve_while, mean_apply=myve_apply, mean_int=mymean)
myResult[1:4, -c(1,2,3)]
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##           C4         C5    mean_for  mean_while  mean_apply    mean_int
## 1  0.2950553  0.9858471  1.02839310  1.02839310  1.02839310  1.02839310
## 2 -0.3208423 -0.4600894  0.02947028  0.02947028  0.02947028  0.02947028
## 3  0.9574395  1.0390970  0.42067691  0.42067691  0.42067691  0.42067691
## 4 -1.3904486 -0.1612300 -0.54604574 -0.54604574 -0.54604574 -0.54604574
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;exercise-2&#34;&gt;Exercise 2&lt;/h2&gt;
&lt;h3 id=&#34;custom-functions&#34;&gt;Custom functions&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;Task 2.1&lt;/strong&gt;: Use the following code as basis to implement a function that allows the user to compute the mean for any combination of columns in a matrix or data frame. The first argument of this function should specify the input data set, the second the mathematical function to be passed on (&lt;em&gt;e.g.&lt;/em&gt; &lt;code&gt;mean&lt;/code&gt;, &lt;code&gt;sd&lt;/code&gt;, &lt;code&gt;max&lt;/code&gt;) and the third one should allow the selection of the columns by providing a grouping vector.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;myMA &amp;lt;- matrix(rnorm(100000), 10000, 10, dimnames=list(1:10000, paste(&amp;quot;C&amp;quot;, 1:10, sep=&amp;quot;&amp;quot;)))
myMA[1:2,]
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##           C1         C2         C3         C4        C5         C6        C7          C8        C9
## 1  0.2457294  1.0377898 -0.1467638 -0.3248598 0.6157826 -1.4879414 2.0392123 -0.08362708 0.5044756
## 2 -0.8500019 -0.7396865 -0.2914722  1.0449035 0.4690041 -0.2100562 0.7917301  0.17614233 0.3136505
##          C10
## 1 -0.6699119
## 2 -0.6938574
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;myList &amp;lt;- tapply(colnames(myMA), c(1,1,1,2,2,2,3,3,4,4), list) 
names(myList) &amp;lt;- sapply(myList, paste, collapse=&amp;quot;_&amp;quot;)
myMAmean &amp;lt;- sapply(myList, function(x) apply(myMA[,x], 1, mean))
myMAmean[1:4,] 
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##      C1_C2_C3    C4_C5_C6      C7_C8      C9_C10
## 1  0.37891844 -0.39900621  0.9777926 -0.08271812
## 2 -0.62705354  0.43461709  0.4839362 -0.19010345
## 3  0.44567197 -0.03322511 -0.1556891 -0.56857498
## 4 -0.07690464  0.66825754 -0.3142668 -0.43291652
&lt;/code&gt;&lt;/pre&gt;
&lt;!---
Solution

--&gt;
&lt;h2 id=&#34;exercise-3&#34;&gt;Exercise 3&lt;/h2&gt;
&lt;h3 id=&#34;nested-loops-to-generate-similarity-matrices&#34;&gt;Nested loops to generate similarity matrices&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;Task 3.1&lt;/strong&gt;: Create a sample list populated with character vectors of different lengths&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;setlist &amp;lt;- lapply(11:30, function(x) sample(letters, x, replace=TRUE))
names(setlist) &amp;lt;- paste(&amp;quot;S&amp;quot;, seq(along=setlist), sep=&amp;quot;&amp;quot;) 
setlist[1:6]
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## $S1
##  [1] &amp;quot;t&amp;quot; &amp;quot;y&amp;quot; &amp;quot;l&amp;quot; &amp;quot;w&amp;quot; &amp;quot;x&amp;quot; &amp;quot;c&amp;quot; &amp;quot;w&amp;quot; &amp;quot;i&amp;quot; &amp;quot;n&amp;quot; &amp;quot;v&amp;quot; &amp;quot;v&amp;quot;
## 
## $S2
##  [1] &amp;quot;t&amp;quot; &amp;quot;f&amp;quot; &amp;quot;q&amp;quot; &amp;quot;z&amp;quot; &amp;quot;e&amp;quot; &amp;quot;g&amp;quot; &amp;quot;u&amp;quot; &amp;quot;m&amp;quot; &amp;quot;q&amp;quot; &amp;quot;t&amp;quot; &amp;quot;l&amp;quot; &amp;quot;f&amp;quot;
## 
## $S3
##  [1] &amp;quot;j&amp;quot; &amp;quot;g&amp;quot; &amp;quot;t&amp;quot; &amp;quot;z&amp;quot; &amp;quot;l&amp;quot; &amp;quot;q&amp;quot; &amp;quot;p&amp;quot; &amp;quot;k&amp;quot; &amp;quot;a&amp;quot; &amp;quot;k&amp;quot; &amp;quot;s&amp;quot; &amp;quot;q&amp;quot; &amp;quot;y&amp;quot;
## 
## $S4
##  [1] &amp;quot;y&amp;quot; &amp;quot;g&amp;quot; &amp;quot;j&amp;quot; &amp;quot;n&amp;quot; &amp;quot;a&amp;quot; &amp;quot;x&amp;quot; &amp;quot;h&amp;quot; &amp;quot;a&amp;quot; &amp;quot;t&amp;quot; &amp;quot;q&amp;quot; &amp;quot;f&amp;quot; &amp;quot;u&amp;quot; &amp;quot;p&amp;quot; &amp;quot;n&amp;quot;
## 
## $S5
##  [1] &amp;quot;i&amp;quot; &amp;quot;c&amp;quot; &amp;quot;y&amp;quot; &amp;quot;e&amp;quot; &amp;quot;k&amp;quot; &amp;quot;u&amp;quot; &amp;quot;j&amp;quot; &amp;quot;v&amp;quot; &amp;quot;t&amp;quot; &amp;quot;u&amp;quot; &amp;quot;q&amp;quot; &amp;quot;w&amp;quot; &amp;quot;b&amp;quot; &amp;quot;q&amp;quot; &amp;quot;s&amp;quot;
## 
## $S6
##  [1] &amp;quot;w&amp;quot; &amp;quot;i&amp;quot; &amp;quot;d&amp;quot; &amp;quot;u&amp;quot; &amp;quot;w&amp;quot; &amp;quot;m&amp;quot; &amp;quot;o&amp;quot; &amp;quot;u&amp;quot; &amp;quot;v&amp;quot; &amp;quot;k&amp;quot; &amp;quot;m&amp;quot; &amp;quot;t&amp;quot; &amp;quot;b&amp;quot; &amp;quot;h&amp;quot; &amp;quot;h&amp;quot; &amp;quot;v&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;Task 3.2&lt;/strong&gt;: Compute the length for all pairwise intersects of the vectors stored in &lt;code&gt;setlist&lt;/code&gt;. The intersects can be determined with the &lt;code&gt;%in%&lt;/code&gt; function like this: &lt;code&gt;sum(setlist[[1]] %in% setlist[[2]])&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;setlist &amp;lt;- sapply(setlist, unique)
olMA &amp;lt;- sapply(names(setlist), function(x) sapply(names(setlist), 
               function(y) sum(setlist[[x]] %in% setlist[[y]])))
olMA[1:12,] 
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##     S1 S2 S3 S4 S5 S6 S7 S8 S9 S10 S11 S12 S13 S14 S15 S16 S17 S18 S19 S20
## S1   9  2  3  4  6  4  4  4  5   5   6   5   5   3   5   5   4   6   7   7
## S2   2  9  5  5  4  3  4  5  4   6   4   6   5   7   5   4   5   7   5   7
## S3   3  5 11  7  6  2  4  6  5   3   7   7   5   8   6   5   7   5   6  10
## S4   4  5  7 12  5  3  6  6  3   6   5   6   6   8   7   6   8   6   7   9
## S5   6  4  6  5 13  7  4  3  5   6   9   7   7   7   9   4   8   8   8  11
## S6   4  3  2  3  7 11  3  3  4   7   6   8   4   6   6   6   8   9   7   8
## S7   4  4  4  6  4  3 12  6  5   7   6   6   8   7   7   7   9   8   9   9
## S8   4  5  6  6  3  3  6 10  7   5   5   5   6   7   4   7   6   5   7   9
## S9   5  4  5  3  5  4  5  7 11   5   6   7   6   6   7   7   5   6   7   9
## S10  5  6  3  6  6  7  7  5  5  14   6   8   6   8   7   9   8   8  11   9
## S11  6  4  7  5  9  6  6  5  6   6  13   7   4   8  10   6  10   9  10  10
## S12  5  6  7  6  7  8  6  5  7   8   7  15   6  10   8   9  10  10   7  11
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;Task 3.3&lt;/strong&gt; Plot the resulting intersect matrix as heat map. The &lt;code&gt;image&lt;/code&gt; or the &lt;code&gt;heatmap.2&lt;/code&gt; function from the &lt;code&gt;gplots&lt;/code&gt; library can be used for this.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;image(olMA)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;../en/tutorials/rprogramming/rprogramming_files/figure-html/nested_loops3-1.png&#34; width=&#34;672&#34; /&gt;&lt;/p&gt;
&lt;h2 id=&#34;exercise-4&#34;&gt;Exercise 4&lt;/h2&gt;
&lt;h3 id=&#34;build-your-own-r-package&#34;&gt;Build your own R package&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;Task 4.1&lt;/strong&gt;: Save one or more of your functions to a file called &lt;code&gt;script.R&lt;/code&gt; and build the package with the &lt;code&gt;package.skeleton&lt;/code&gt; function.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;package.skeleton(name=&amp;quot;mypackage&amp;quot;, code_files=c(&amp;quot;script1.R&amp;quot;))
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;Task 4.2&lt;/strong&gt;: Build tarball of the package&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;system(&amp;quot;R CMD build mypackage&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;Task 4.3&lt;/strong&gt;: Install and use package&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;install.packages(&amp;quot;mypackage_1.0.tar.gz&amp;quot;, repos=NULL, type=&amp;quot;source&amp;quot;)
library(mypackage)
?myMAcomp # Opens help for function defined by mypackage
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;homework-5&#34;&gt;Homework 5&lt;/h1&gt;
&lt;h2 id=&#34;reverse-and-complement-of-dna&#34;&gt;Reverse and complement of DNA&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;Task 1&lt;/strong&gt;: Write a &lt;code&gt;RevComp&lt;/code&gt; function that returns the reverse and complement of a DNA sequence string. Include an argument that will allow to return only the reversed sequence, the complemented sequence or the reversed and complemented sequence. The following R functions will be useful for the implementation:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;x &amp;lt;- c(&amp;quot;ATGCATTGGACGTTAG&amp;quot;)  
x
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] &amp;quot;ATGCATTGGACGTTAG&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;x &amp;lt;- substring(x, 1:nchar(x), 1:nchar(x)) 
x
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##  [1] &amp;quot;A&amp;quot; &amp;quot;T&amp;quot; &amp;quot;G&amp;quot; &amp;quot;C&amp;quot; &amp;quot;A&amp;quot; &amp;quot;T&amp;quot; &amp;quot;T&amp;quot; &amp;quot;G&amp;quot; &amp;quot;G&amp;quot; &amp;quot;A&amp;quot; &amp;quot;C&amp;quot; &amp;quot;G&amp;quot; &amp;quot;T&amp;quot; &amp;quot;T&amp;quot; &amp;quot;A&amp;quot; &amp;quot;G&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;x &amp;lt;- rev(x) 
x
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##  [1] &amp;quot;G&amp;quot; &amp;quot;A&amp;quot; &amp;quot;T&amp;quot; &amp;quot;T&amp;quot; &amp;quot;G&amp;quot; &amp;quot;C&amp;quot; &amp;quot;A&amp;quot; &amp;quot;G&amp;quot; &amp;quot;G&amp;quot; &amp;quot;T&amp;quot; &amp;quot;T&amp;quot; &amp;quot;A&amp;quot; &amp;quot;C&amp;quot; &amp;quot;G&amp;quot; &amp;quot;T&amp;quot; &amp;quot;A&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;x &amp;lt;- paste(x, collapse=&amp;quot;&amp;quot;)
x
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] &amp;quot;GATTGCAGGTTACGTA&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;chartr(&amp;quot;ATGC&amp;quot;, &amp;quot;TACG&amp;quot;, x) 
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] &amp;quot;CTAACGTCCAATGCAT&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;Task 2&lt;/strong&gt;: Write a function that applies the &lt;code&gt;RevComp&lt;/code&gt; function to many sequences stored in a vector.&lt;/p&gt;
&lt;h2 id=&#34;translate-dna-into-protein&#34;&gt;Translate DNA into Protein&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;Task 3&lt;/strong&gt;: Write a function that will translate one or many DNA sequences in all three reading frames into proteins. The following commands will simplify this task:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;AAdf &amp;lt;- read.table(file=&amp;quot;http://faculty.ucr.edu/~tgirke/Documents/R_BioCond/My_R_Scripts/AA.txt&amp;quot;, header=TRUE, sep=&amp;quot;\t&amp;quot;) 
AAdf[1:4,]
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##   Codon AA_1 AA_3 AA_Full AntiCodon
## 1   TCA    S  Ser  Serine       TGA
## 2   TCG    S  Ser  Serine       CGA
## 3   TCC    S  Ser  Serine       GGA
## 4   TCT    S  Ser  Serine       AGA
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;AAv &amp;lt;- as.character(AAdf[,2]) 
names(AAv) &amp;lt;- AAdf[,1] 
AAv
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## TCA TCG TCC TCT TTT TTC TTA TTG TAT TAC TAA TAG TGT TGC TGA TGG CTA CTG CTC CTT CCA CCG CCC CCT CAT 
## &amp;quot;S&amp;quot; &amp;quot;S&amp;quot; &amp;quot;S&amp;quot; &amp;quot;S&amp;quot; &amp;quot;F&amp;quot; &amp;quot;F&amp;quot; &amp;quot;L&amp;quot; &amp;quot;L&amp;quot; &amp;quot;Y&amp;quot; &amp;quot;Y&amp;quot; &amp;quot;*&amp;quot; &amp;quot;*&amp;quot; &amp;quot;C&amp;quot; &amp;quot;C&amp;quot; &amp;quot;*&amp;quot; &amp;quot;W&amp;quot; &amp;quot;L&amp;quot; &amp;quot;L&amp;quot; &amp;quot;L&amp;quot; &amp;quot;L&amp;quot; &amp;quot;P&amp;quot; &amp;quot;P&amp;quot; &amp;quot;P&amp;quot; &amp;quot;P&amp;quot; &amp;quot;H&amp;quot; 
## CAC CAA CAG CGA CGG CGC CGT ATT ATC ATA ATG ACA ACG ACC ACT AAT AAC AAA AAG AGT AGC AGA AGG GTA GTG 
## &amp;quot;H&amp;quot; &amp;quot;Q&amp;quot; &amp;quot;Q&amp;quot; &amp;quot;R&amp;quot; &amp;quot;R&amp;quot; &amp;quot;R&amp;quot; &amp;quot;R&amp;quot; &amp;quot;I&amp;quot; &amp;quot;I&amp;quot; &amp;quot;I&amp;quot; &amp;quot;M&amp;quot; &amp;quot;T&amp;quot; &amp;quot;T&amp;quot; &amp;quot;T&amp;quot; &amp;quot;T&amp;quot; &amp;quot;N&amp;quot; &amp;quot;N&amp;quot; &amp;quot;K&amp;quot; &amp;quot;K&amp;quot; &amp;quot;S&amp;quot; &amp;quot;S&amp;quot; &amp;quot;R&amp;quot; &amp;quot;R&amp;quot; &amp;quot;V&amp;quot; &amp;quot;V&amp;quot; 
## GTC GTT GCA GCG GCC GCT GAT GAC GAA GAG GGA GGG GGC GGT 
## &amp;quot;V&amp;quot; &amp;quot;V&amp;quot; &amp;quot;A&amp;quot; &amp;quot;A&amp;quot; &amp;quot;A&amp;quot; &amp;quot;A&amp;quot; &amp;quot;D&amp;quot; &amp;quot;D&amp;quot; &amp;quot;E&amp;quot; &amp;quot;E&amp;quot; &amp;quot;G&amp;quot; &amp;quot;G&amp;quot; &amp;quot;G&amp;quot; &amp;quot;G&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;y &amp;lt;- gsub(&amp;quot;(...)&amp;quot;, &amp;quot;\\1_&amp;quot;, x) 
y &amp;lt;- unlist(strsplit(y, &amp;quot;_&amp;quot;)) 
y &amp;lt;- y[grep(&amp;quot;^...$&amp;quot;, y)] 
AAv[y] 
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## GAT TGC AGG TTA CGT 
## &amp;quot;D&amp;quot; &amp;quot;C&amp;quot; &amp;quot;R&amp;quot; &amp;quot;L&amp;quot; &amp;quot;R&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;homework-submission&#34;&gt;Homework submission&lt;/h2&gt;
&lt;p&gt;Submit the 3 functions in one well structured and annotated R script to the instructor. The script should include instructions on how to use the functions.&lt;/p&gt;
&lt;h2 id=&#34;due-date&#34;&gt;Due date&lt;/h2&gt;
&lt;p&gt;This homework is due on Thu, April 26th at 6:00 PM.&lt;/p&gt;
&lt;h2 id=&#34;homework-solutions&#34;&gt;Homework Solutions&lt;/h2&gt;
&lt;p&gt;See &lt;a href=&#34;https://drive.google.com/open?id=17Hs8UzqoZL-7z2eqZs8h6FEZeWZm5hcW&#34;&gt;here&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&#34;session-info&#34;&gt;Session Info&lt;/h1&gt;
&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;sessionInfo()
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## R version 4.0.3 (2020-10-10)
## Platform: x86_64-pc-linux-gnu (64-bit)
## Running under: Debian GNU/Linux 10 (buster)
## 
## Matrix products: default
## BLAS:   /usr/lib/x86_64-linux-gnu/blas/libblas.so.3.8.0
## LAPACK: /usr/lib/x86_64-linux-gnu/lapack/liblapack.so.3.8.0
## 
## locale:
##  [1] LC_CTYPE=en_US.UTF-8       LC_NUMERIC=C               LC_TIME=en_US.UTF-8       
##  [4] LC_COLLATE=en_US.UTF-8     LC_MONETARY=en_US.UTF-8    LC_MESSAGES=en_US.UTF-8   
##  [7] LC_PAPER=en_US.UTF-8       LC_NAME=C                  LC_ADDRESS=C              
## [10] LC_TELEPHONE=C             LC_MEASUREMENT=en_US.UTF-8 LC_IDENTIFICATION=C       
## 
## attached base packages:
## [1] stats     graphics  grDevices utils     datasets  methods   base     
## 
## other attached packages:
## [1] ggplot2_3.3.2    limma_3.46.0     BiocStyle_2.18.0
## 
## loaded via a namespace (and not attached):
##  [1] knitr_1.30          magrittr_2.0.1      tidyselect_1.1.0    munsell_0.5.0      
##  [5] colorspace_2.0-0    R6_2.5.0            rlang_0.4.8         dplyr_1.0.2        
##  [9] stringr_1.4.0       tools_4.0.3         grid_4.0.3          gtable_0.3.0       
## [13] xfun_0.20           withr_2.3.0         ellipsis_0.3.1      htmltools_0.5.1.1  
## [17] yaml_2.2.1          digest_0.6.27       tibble_3.0.4        lifecycle_0.2.0    
## [21] crayon_1.3.4        bookdown_0.21       purrr_0.3.4         BiocManager_1.30.10
## [25] codetools_0.2-16    vctrs_0.3.5         glue_1.4.2          evaluate_0.14      
## [29] rmarkdown_2.5       blogdown_1.1.7      stringi_1.5.3       pillar_1.4.7       
## [33] compiler_4.0.3      generics_0.1.0      scales_1.1.1        pkgconfig_2.0.3
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;references&#34;&gt;References&lt;/h1&gt;

      </description>
    </item>
    
  </channel>
</rss>
